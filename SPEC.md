# Logix as a text
## 用語定義
1. LaaD: Logix as a DSL。
2. LNJ: Logix native JSON。LogixをJSONとしてエクスポートしたときの表現形式。
3. LZBS: lzma+bson。
4. CLI: 共通言語基盤 (Common Language Interface)

## 動機
* 特に大きいプロジェクトだと限界があるよね
* だからツールチェイン作りたいよね

## 仕様
1. Logix as a DSL
2. LNJ to LaaD stub
3. LNJ-LZBS converter

## Logix as a DSL
### 型システム
* ~~共通言語基盤~~.NET Framework 4.6.1の一部の型と、Flooxオブジェクトのすべてをサポート

#### 用語
1. スカラー型: 整数型または小数型または文字型または`boolean`
2. 整数型: 符号付き整数型または符号なし整数型
3. 符号なし整数型: `u(8|16|32|64)`
4. 符号付き整数型: `i(8|16|32|64)`
5. 小数型: `f32|f64|decimal`
6. 文字型: `c16|c32`

#### 対応表
|   LaaD   |      CLI       |  logix  | Flag  |
|:---------|:---------------|:--------|:------|
|`u8`      |`System.Int8`   |`byte`   |`P-X-` |
|`i8`      |`System.SByte`  |`sbyte`  |`--X-` |
|`u16`     |`System.UInt16` |`ushort` |`--X-` |
|`i16`     |`System.Int16`  |`short`  |`--X-` |
|`u32`     |`System.UInt32` |`uint`   |`--X-` |
|`i32`     |`System.Int32`  |`int`    |`P-X-` |
|`u64`     |`System.UInt64` |`ulong`  |`P-X-` |
|`i64`     |`System.Int64`  |`long`   |`P-X-` |
|`f32`     |`System.Single` |`float`  |`P-LM` |
|`f64`     |`System.Double` |`double` |`P-LM` |
|`bool`    |`System.Bool`   |`bool`   |`P-X-` |
|`c16`     |`System.Char`   |`char`   |`--X-` |
|`c32`     |`N/A`           |`int`    |`-QX-` |
|`decimal` |`System.Decimal`|`decimal`|`--X-` |

* 実装上の注: `c16`はUTF-16のコードポイントであり、絵文字などのハンドリングをする際には**特に**注意を必要とする。
* 実装上の注: `c32`はUTF-32のコードポイントである。

#### Packable type
* 以下の型はそれぞれLogixの「Input」カテゴリ内の`*2`, `*3`, `*4`としてコンパイルされる。
* 要素の型は上記のNoteに`P`フラグが立っている型でなければならない (MUST)
	* それ以外の型を使おうとした場合はコンパイルエラーにならなければならない (MUST)

|   LaaD   |CLI|
|:---------|:--|
|`Pack2<T>`|`BaseX.*2`|
|`Pack3<T>`|`BaseX.*3`|
|`Pack4<T>`|`BaseX.*4`|

#### Matrix type
* 以下の型はそれぞれLogixの「Input」カテゴリ内の`*2x2`, `*3x3`, `*4x4`としてコンパイルされる。
* 要素の型は上記のNoteに`M`フラグが立っている型でなければならない (MUST)
	* それ以外の型を使おうとした場合はコンパイルエラーにならなければならない (MUST)

|    LaaD    |CLI|
|:-----------|:--|
|`Matrix2<T>`|`BaseX.*2`|
|`Matrix3<T>`|`BaseX.*3`|
|`Matrix4<T>`|`BaseX.*4`|

#### Opaque type
* 上記のFlagに`Q`フラグが立っている型はDSL上にのみ存在し、コンパイル時の出力では他の型に変換されているOpaque typeである
* Opaque typeは内部の型に暗黙に変換されることはない

##### 変換表
| DSL |inner type|Logix|
|:----|:---------|:----|
|`c32`|   `i32`  |`int`|

#### サブタイピング
* スカラー型は互いに他のスカラー型のサブタイプではない (MUST NOT)
* 型`T1`および`T2`が存在し、以下のいずれかを満たすとき、`T2`として型付けされた任意の値`t`は`T1`が要求される文脈へ渡すことができる。
	* `T1`及び`T2`がともにクラスを表し、`T1`が共通言語基盤上で`T2`の親クラスとなっているとき
	* `T2`が共通言語基板上のクラスを、`T1`が共通言語基板上のインターフェースを表し、かつ`T2`が共通言語基板上で`T1`を実装しているとき
	* `T1`及び`T2`がともにインターフェースを表し、`T1`が共通言語基盤上で`T2`の親インターフェースとなっているとき
	* 型`T3`が存在し、`T2`が`T3`のサブタイプかつ`T3`が`T1`のサブタイプであるとき

(以下スタブ)
* 変性チェッカー
	* `TpN`の変性を調べる
		* `TpN`が反変であるとき、`T2.TpN`が`T1.TpN`のサブタイプ
		* `TpN`が不変であるとき、`T1.TpN`が`T2.TpN`と等しい
		* `TpN`が共変であるとき、`T1.TpN`が`T2.TpN`のサブタイプ
	* すべての型変数が検査を通過した場合、サブタイプと判定

##### 変性チェッカーの例 (Scala)
```scala
sealed trait Option[+A]

case class Some[+A](value: A) extends Option[A]
case class None extends Option[Nothing]

// OK
val opt: Option[Int] = Some(1)

// OK
val opt2: Option[Int] = None
```
(スタブここまで)

#### 暗黙の型変換
* 通常の代入ルールに従って代入が行えない場合は、暗黙の型変換が発生することがある
* 以下の場合、式の型を変換先の型として扱うべきである (SHOULD)
	* 式の型が`i8`で、代入先が`i16`・`i32`・`i64`・`f32`・`f64`
	* 式の型が`i16`で、代入先が`i32`・`i64`・`f32`・`f64`
	* 式の型が`i32`で、代入先が`i64`・`f64`
	* 式の型が`u8`で、代入先が`u16`・`u32`・`u64`・`i16`・`i32`・`i64`
	* 式の型が`u16`で、代入先が`u32`・`u64`・`i32`・`i64`
	* 式の型が`u32`で、代入先が`u64`・`i64`
	* 式の型が整数型のいずれかで、代入先が`dec`
* 実装上の注: 以下の場合は暗黙の型変換は起こらない (MUST NOT)
	* 情報の喪失が発生する可能性がある型ペアの間
		* 大きい整数型から小さい整数型
		* 小数型同士の間
			* `dec`の`0.1`を`f32`や`f64`では表現できない
			* `f32`や`f64`から`dec`は私が安全性を証明できていないため現在のところは不許可
		* `u8`と`i8`など、同じビット数で符号の有無のみが異なる整数型の組での間
			* 代わりに`laad.bit_cast`を使う

* 実装上の注: `f32`が精度を失うことなく扱える整数の範囲は±`16777216` (2の24乗) である
* 実装上の注: `f64`が精度を失うことなく扱える整数の範囲は±`9007199254740992` (2の53乗) である
 
#### キャスト
##### 通常のキャスト
* 簡便のため、キャストは推移的**ではない**
* 以下のいずれかの場合、キャストが許される
	* 

##### bit_cast
* `laad.bit_cast`を使って通常のキャストでできる変換に加えて、次の「ビットキャスト」が追加で許される (MUST)
* ビットキャストはビット列を変更せず (MUST NOT)、ビット列の解釈方法を変更する (MUST)
  * すなわち、型`T`を持つ値`t`を`laad.bit_cast`で型`Q`へビットキャストし、再度`laad.bit_cast`でビットキャストした結果は`t`と等しくなる必要がある (MUST)

| 変換元 | 変換先 |
|:-----:|:-----:|
| `u8`  | `i8`  |
| `u16` | `i16` |
| `u32` | `i32` |
| `u64` | `i64` |
| `i8`  | `u8`  |
| `i16` | `u16` |
| `i32` | `u32` |
| `i64` | `u64` |
| `f32` | `u32` |
| `u32` | `f32` |
| `f64` | `u64` |
| `u64` | `f64` |

実装上の注: `f32` <-> `u32` および `f64` <-> `u64` は アンパック時の読みやすさのために `Logix > Math > Binary`下の特殊化されたノードを使っても良い。

### stubファイル
* C言語における`#include <stdio.h>`みたいなことをしたい
* 既存のLNJとの相互IOを想定

### リテラル
* 整数は整数型または小数型のいずれかとして扱われる (MUST)
* 小数は小数型のいずれかとして扱われる (MUST)
* ダブルクォーテーションでくくられた文字列は文字列リテラルとして扱われる (MUST)
* シングルクォーテーションでくくられた一文字は文字型のいずれかとして扱われる

### 演算子
演算子は中置記法。ノードのシンタックスシュガーであることが期待される (SHOULD)

### 最適化
* コンパイル時にはノードの数を減らすなど最適化が行われても良い (MAY)
* 最適化においてコードの動作を変えてはならない (MUST NOT)


## LNJ to LaaD stub
*stub* (self referencing joke, but to be determined)

## LNJ-LZBS converter
* LZBSはlzmaを解凍してBSONをJSONにするとLNJになる。
* LNJはJSONをBSONにしてlzmaで圧縮するとLZBSになる。

## L4B2LNJ
* LiteDBにはlz4bsonという別の形式で保存されている (独立したファイルとして見えるようになっている)。

