# Logix as a text
## 用語定義
1. LaaD: Logix as a DSL。
2. LNJ: Logix native JSON。LogixをJSONとしてエクスポートしたときの表現形式。
3. LZBS: lzma+bson。
4. CLI: 共通言語基盤 (Common Language Interface)

## 動機
* 特に大きいプロジェクトだと限界があるよね
* だからツールチェイン作りたいよね

## 仕様
1. Logix as a DSL
2. LNJ to LaaD stub
3. LNJ-LZBS converter

## Logix as a DSL
### 型システム
* ~~共通言語基盤~~.NET Framework 4.6.1の一部の型と、Flooxオブジェクトのすべてをサポート

#### 用語
1. スカラー型: 整数型または小数型または文字型または`boolean`
2. 整数型: 符号付き整数型または符号なし整数型
3. 符号なし整数型: `u(8|16|32|64)`
4. 符号付き整数型: `i(8|16|32|64)`
5. 小数型: `f32|f64|decimal`
6. 文字型: `c16|c32`

#### 対応表
|      LaaD      |      CLI       |  logix  | Flag  |
|:---------------|:---------------|:--------|:------|
|`u8`            |`System.Int8`   |`byte`   |`P-X-` |
|`i8`            |`System.SByte`  |`sbyte`  |`--X-` |
|`u16`           |`System.UInt16` |`ushort` |`--X-` |
|`i16`           |`System.Int16`  |`short`  |`--X-` |
|`u32`           |`System.UInt32` |`uint`   |`--X-` |
|`i32`           |`System.Int32`  |`int`    |`P-X-` |
|`u64`           |`System.UInt64` |`ulong`  |`P-X-` |
|`i64`           |`System.Int64`  |`long`   |`P-X-` |
|`f32`           |`System.Single` |`float`  |`P-LM` |
|`f64`           |`System.Double` |`double` |`P-LM` |
|`bool`          |`System.Bool`   |`bool`   |`P-X-` |
|`c16`           |`System.Char`   |`char`   |`--X-` |
|`c32`           |`N/A`           |`int`    |`-QX-` |
|`decimal`       |`System.Decimal`|`decimal`|`--L-` |
|`GlobalPosition`|`N/A`           |`float3` |`-Q--` |

##### それぞれの型が表現するもの
共通の性質:
* 符号付き整数型はすべて2の補数で表現される
* 整数型のビットがすべて0で埋められた表現は正確に`0`を表す

整数型:
* `u8`: 符号なし8ビット整数
* `i8`: 符号付き8ビット整数
* `u16`: 符号なし16ビット整数
* `i16`: 符号付き16ビット整数
* `u32`: 符号なし32ビット整数
* `i32`: 符号付き32ビット整数
* `u64`: 符号なし64ビット整数
* `i64`: 符号付き64ビット整数

小数型:
* `f32`: IEEE-754において規定されている単精度浮動小数点数
* `f64`: IEEE-754において規定されている倍精度浮動小数点数
* `decimal`: 以下のすべてを満たす (<a href="https://docs.microsoft.com/en-us/dotnet/api/system.decimal.-ctor?view=netframework-4.6.1#system-decimal-ctor(system-int32())">C#</a>)
	* 内部的に128ビットの幅を持つ
	* 先頭の96ビットが仮数部を表す
	* 残りの32ビットのうち:
		* 先頭から16ビット目から23ビット目までが指数部を表す
		* 残りのビットはゼロで埋められている
	* 浮動小数点数

文字型:
* `c16`: UTF-16のコードポイント
	* 実装上の注: 絵文字などのハンドリングをする際には**特に**注意を必要とする。
* `c32`: UTF-32のコードポイント

その他の型:
* `bool`: `true` または `false` として表現される論理値
* `GlobalPosition`: オブジェクトが存在するワールドの原点を`(0, 0, 0)`とし、3次元空間上に定められたX軸、Y軸、Z軸がそれぞれ直交するように定められた仮想空間上のある一点を指す座標

#### Packable type
* 以下の型はそれぞれLogixの「Input」カテゴリ内の`*2`, `*3`, `*4`としてコンパイルされる。
* 要素の型は上記のNoteに`P`フラグが立っている型でなければならない (MUST)
	* それ以外の型を使おうとした場合はコンパイルエラーにならなければならない (MUST)

|   LaaD   |CLI|
|:---------|:--|
|`Pack2<T>`|`BaseX.*2`|
|`Pack3<T>`|`BaseX.*3`|
|`Pack4<T>`|`BaseX.*4`|

#### Matrix type
* 以下の型はそれぞれLogixの「Input」カテゴリ内の`*2x2`, `*3x3`, `*4x4`としてコンパイルされる。
* 要素の型は上記のNoteに`M`フラグが立っている型でなければならない (MUST)
	* それ以外の型を使おうとした場合はコンパイルエラーにならなければならない (MUST)

|    LaaD    |CLI|
|:-----------|:--|
|`Matrix2<T>`|`BaseX.*2`|
|`Matrix3<T>`|`BaseX.*3`|
|`Matrix4<T>`|`BaseX.*4`|

#### Opaque type
* 上記のFlagに`Q`フラグが立っている型はDSL上にのみ存在し、コンパイル時の出力では他の型に変換されているOpaque typeである
* Opaque typeは内部の型に暗黙に変換されることはない

##### 変換表
|      DSL       |   inner type   |Logix   |
|:---------------|:---------------|:-------|
|`c32`           |`i32`           |`int`   |
|`GlobalPosition`|`Matrix3<f32>`  |`float3`|

#### Loose or eXact
* 上記のFlagに`L`が立っている場合、リテラルを記述してもそのリテラルと真に等しい値になるとは限らない
	* 例: `f32`が期待される文脈で`0.1` と記述しても正確に `0.1` になるわけではない
* 上記のFlagに`X`が立っている場合、リテラルを記述するとその型が許す範囲内で正確な値が出力される
	* 例: `i32`が期待される文脈で`1` と記述すると正確に `1` になる

#### サブタイピング
* スカラー型は互いに他のスカラー型のサブタイプではない (MUST NOT)
* 型`T1`および`T2`が存在し、以下のいずれかを満たすとき、`T2`として型付けされた任意の値`t`は`T1`が要求される文脈へ渡すことができる。
	* `T1`及び`T2`がともにクラスを表し、`T1`が共通言語基盤上で`T2`の親クラスとなっているとき
	* `T2`が共通言語基板上のクラスを、`T1`が共通言語基板上のインターフェースを表し、かつ`T2`が共通言語基板上で`T1`を実装しているとき
	* `T1`及び`T2`がともにインターフェースを表し、`T1`が共通言語基盤上で`T2`の親インターフェースとなっているとき
	* 型`T3`が存在し、`T2`が`T3`のサブタイプかつ`T3`が`T1`のサブタイプであるとき

(以下スタブ)
* 変性チェッカー
	* `TpN`の変性を調べる
		* `TpN`が反変であるとき、`T2.TpN`が`T1.TpN`のサブタイプ
		* `TpN`が不変であるとき、`T1.TpN`が`T2.TpN`と等しい
		* `TpN`が共変であるとき、`T1.TpN`が`T2.TpN`のサブタイプ
	* すべての型変数が検査を通過した場合、サブタイプと判定

##### 変性チェッカーの例 (Scala)
```scala
sealed trait Option[+A]

case class Some[+A](value: A) extends Option[A]
case class None extends Option[Nothing]

// OK
val opt: Option[Int] = Some(1)

// OK
val opt2: Option[Int] = None
```
(スタブここまで)

* 実装上の注: `f32`が精度を失うことなく扱える整数の範囲は±`16777216` (2の24乗) である
* 実装上の注: `f64`が精度を失うことなく扱える整数の範囲は±`9007199254740992` (2の53乗) である
 
#### キャスト
通常の代入ルールに適合せず、暗黙の型変換も起こらなかった場合、型を合わせるためにキャストが挿入される必要がある

#### 安全なキャスト
* 通常の代入ルールに従って代入が行えない場合は、安全なキャストが必要なことがある
* 安全なキャストの定義：
	* キャストの前後でその式が表現する値が変わらない (すなわち、`expr as Foo == expr`となる必要がある)
* 以下の場合、より形式的に示された安全なキャストであり、コンパイラは許可しなければならない (MUST)
	* 式の型が`i8`で、代入先が`i16`・`i32`・`i64`・`f32`・`f64`
	* 式の型が`i16`で、代入先が`i32`・`i64`・`f32`・`f64`
	* 式の型が`i32`で、代入先が`i64`・`f64`
	* 式の型が`u8`で、代入先が`u16`・`u32`・`u64`・`i16`・`i32`・`i64`
	* 式の型が`u16`で、代入先が`u32`・`u64`・`i32`・`i64`
	* 式の型が`u32`で、代入先が`u64`・`i64`
	* 式の型が整数型のいずれかで、代入先が`dec`
	* 式の型が任意の型`T`で、代入先も`T`
* 実装上の注: 以下の場合は暗黙の型変換は起こらない (MUST NOT)
	* 情報の喪失が発生する可能性がある型ペアの間
		* 大きい整数型から小さい整数型
		* 小数型同士の間
			* `dec`の`0.1`を`f32`や`f64`では表現できない
			* `f32`や`f64`から`dec`は私が安全性を証明できていないため現在のところは不許可
		* `u8`と`i8`など、同じビット数で符号の有無のみが異なる整数型の組での間
			* 代わりに`laad.bit_cast`を使う

##### 通常のキャスト
* 簡便のため、キャストは推移的**ではない**
* 以下のいずれかの場合、キャストが許される
	* ビット幅が大きい整数型から小さい整数型
	* 小数型同士
* 文字列から整数型、小数型から整数型へのキャストはセマンティクスが不明確になるため明示的なメソッドを使うべき

##### bit_cast
* `laad.bit_cast`を使って通常のキャストでできる変換に加えて、次の「ビットキャスト」が追加で許される (MUST)
* ビットキャストはビット列を変更せず (MUST NOT)、ビット列の解釈方法を変更する (MUST)
  * すなわち、型`T`を持つ値`t`を`laad.bit_cast`で型`Q`へビットキャストし、再度`laad.bit_cast`でビットキャストした結果は`t`と等しくなる必要がある (MUST)

| 変換元 | 変換先 |
|:-----:|:-----:|
| `u8`  | `i8`  |
| `u16` | `i16` |
| `u32` | `i32` |
| `u64` | `i64` |
| `i8`  | `u8`  |
| `i16` | `u16` |
| `i32` | `u32` |
| `i64` | `u64` |
| `f32` | `u32` |
| `u32` | `f32` |
| `f64` | `u64` |
| `u64` | `f64` |

実装上の注: `f32` <-> `u32` および `f64` <-> `u64` は アンパック時の読みやすさのために `Logix > Math > Binary`下の特殊化されたノードを使っても良い。

### stubファイル
* C言語における`#include <stdio.h>`みたいなことをしたい
* 既存のLNJとの相互IOを想定

### リテラル
* 整数は整数型または小数型のいずれかとして扱われる (MUST)
* 小数は小数型のいずれかとして扱われる (MUST)
* ダブルクォーテーションでくくられた文字列は文字列リテラルとして扱われる (MUST)
* シングルクォーテーションでくくられた一文字は文字型のいずれかとして扱われる

#### 整数リテラル
* 整数リテラルは要求された文脈に応じて整数型のいずれか、または小数型のいずれかとして扱われなければならない (MUST)
	* 要求された文脈が小数型であり、そのリテラルの値が要求された文脈が要求する型で正確に表現できないとき、警告を送出しても良い (MAY)
		* 例: `f64`に絶対値が2の53乗に1を加えた数より大きい整数リテラルを渡す
* 型推論の過程において整数リテラルの要求された文脈を考慮しても、そのリテラルの型が一つに決定できなかった場合、次の順序で決定する (MUST)
	1. 要求された文脈においていかなる型に解決しても構わない場合、`i32`
	2. 要求された文脈の解決候補が多相ではなく、候補に`i32`が含まれている場合は`i32`
	3. 上記に当てはまらない場合はエラー
* リテラルの値が解決された型で表現できる最小値未満、あるいは解決された方で表現できる最大値より大きい場合はコンパイルエラーを送出するべきである (SHOULD)

#### 小数リテラル
* 小数リテラルは要求された文脈に応じて小数型のいずれかとして扱われなければならない (MUST)
	* リテラルの値が要求された文脈が要求する型で正確に表現できないとき、警告を送出しても良い (MAY)
* 型推論の過程において小数リテラルの要求された文脈を考慮しても、そのリテラルの型が一つに決定できなかった場合、次の順序で決定する (MUST)
	1. 要求された文脈においていかなる型に解決しても構わない場合、`f32`
	2. 要求された文脈の解決候補が多相ではなく、候補に`f32`が含まれている場合は`f32`
	3. 上記に当てはまらない場合はエラー
* リテラルの値が解決された型で表現できる最小値未満、あるいは解決された方で表現できる最大値より大きい場合はコンパイルエラーを送出するべきである (SHOULD)

#### 文字列リテラル
* 文字列リテラルは文字列型を表現する
* 文字列の内部エンコーディングは未規定である
* 文字列はすべてのUnicodeの文字を保持できる
* 文字列リテラル内には任意のUnicodeの文字を保持できる

#### 文字リテラル
* 文字リテラルは正確に一つの「ルーン」を表現する
	* その性質上、「🇯🇵」などの1書記素クラスタは文字リテラルに入れることができない
* ルーンはそのリテラルが解決される文脈によって保持する中身が異なる：
	* `c16`: UTF-16の1コードポイント
	* `c32`: UTF-32の1コードポイント
* その性質上、0ルーンの文字リテラルや2ルーン以上の文字リテラルはコンパイルエラーにならなければならない

### 演算
#### 演算子
* 演算子は中置記法。
* `Operator`カテゴリ下のシンタックスシュガーであることが期待される (SHOULD)
	* すなわち、`1 + 2`などと書いたとき、`Operator > +`ノードに (`Action > Write` などを挟まずに) そのままコンパイルされることが期待される (SHOULD)
* 被剰余数が負数のときの挙動について：絶対値最小剰余に従う (MUST)。すなわち：
	* `-5 % 3`は`-2`であって`1`ではない。
	* `5 % -3`は`2`であって`-1`ではない。
#### アンダーフロー
* アンダーフローは浮動小数点数の演算結果がゼロに近づきすぎ、結果がゼロへ丸められることを指す
* アンダーフローは実行時に検知されなくても良い
* アンダーフローが起こる可能性はコンパイル時に検知されなくても良い

#### オーバーフロー
* オーバーフローは値がその型で表現できる最大値または最小値を超えることを指す
* オーバーフローは実行時に検知されなくても良い
* オーバーフローが起こる可能性はコンパイル時に検知されなくても良い

### 最適化
* コンパイル時にはノードの数を減らすなど最適化が行われても良い (MAY)
* 最適化においてコードの動作を変えてはならない (MUST NOT)


## LNJ to LaaD stub
*stub* (self referencing joke, but to be determined)

## LNJ-LZBS converter
* LZBSはlzmaを解凍してBSONをJSONにするとLNJになる。
* LNJはJSONをBSONにしてlzmaで圧縮するとLZBSになる。

## L4B2LNJ
* LiteDBにはlz4bsonという別の形式で保存されている (独立したファイルとして見えるようになっている)。

